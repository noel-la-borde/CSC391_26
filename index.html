<!DOCTYPE html>
<html>
<head>
  <title>Noel La Borde Project</title>
  <meta charset="utf-8">
  <style>
    body { margin: 0; overflow: hidden; }
    #container { width: 100vw; height: 100vh; }
  </style>
</head>
<body>
<div id="container"></div>

<!-- IMPORT MAP -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

let scene, camera, renderer, controls;

init();
animate();

function init() {
  const container = document.getElementById('container');

  // SCENE
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x050505);

  // CAMERA
  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
  camera.position.set(5, 4, 8);

  // RENDERER
  renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  container.appendChild(renderer.domElement);

  // CONTROLS
  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // LIGHTS
  const ambient = new THREE.AmbientLight(0xffffff, 0.3);
  scene.add(ambient);

  const pointLight = new THREE.PointLight(0xff8800, 50, 100);
  pointLight.position.set(2, 5, 2);
  pointLight.castShadow = true;
  scene.add(pointLight);

  // FLOOR
  const loader = new THREE.TextureLoader();
  const woodColor = loader.load('Textures/hardwood2_diffuse.jpg');
  const woodBump = loader.load('Textures/hardwood2_bump.jpg');
  const woodRough = loader.load('Textures/hardwood2_roughness.jpg');

  // Repeat textures
  [woodColor, woodBump, woodRough].forEach(tex => {
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(10, 10);
  });

  woodColor.colorSpace = THREE.SRGBColorSpace;

  const floorMat = new THREE.MeshStandardMaterial({
    map: woodColor,
    bumpMap: woodBump,
    roughnessMap: woodRough,
    roughness: 0.8,
    metalness: 0.2
  });

  const floor = new THREE.Mesh(new THREE.PlaneGeometry(25, 25), floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

   // --- COURT LINES (simple white lines) ---
  const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
  const lines = [];

  // Sidelines and baseline (half court)
  const outlinePoints = [
    new THREE.Vector3(-5.5, 0.01, -7),
    new THREE.Vector3(5.5, 0.01, -7),
    new THREE.Vector3(5.5, 0.01, 7),
    new THREE.Vector3(-5.5, 0.01, 7),
    new THREE.Vector3(-5.5, 0.01, -7)
  ];
  const outlineGeom = new THREE.BufferGeometry().setFromPoints(outlinePoints);
  scene.add(new THREE.Line(outlineGeom, lineMaterial));

  // Free throw semicircle
  const arcPoints = [];
  const radius = 1.8;
  const center = new THREE.Vector3(0, 0.02, -5.2);
  for(let i=-Math.PI/2; i<=Math.PI/2; i+=0.05){
    arcPoints.push(new THREE.Vector3(center.x + Math.cos(i)*radius, center.y, center.z + Math.sin(i)*radius));
  }
  const arcGeom = new THREE.BufferGeometry().setFromPoints(arcPoints);
  scene.add(new THREE.Line(arcGeom, lineMaterial));

  const arcPoints2 = [];
  const radius2 = 2.5;
  const center2 = new THREE.Vector3(-5.2, 0.02, 0);
  for(let i=-Math.PI/2; i<=Math.PI/2; i+=0.05){
    arcPoints2.push(new THREE.Vector3(center2.x + Math.cos(i)*radius2, center2.y, center2.z + Math.sin(i)*radius2));
  }
  const arcGeom2 = new THREE.BufferGeometry().setFromPoints(arcPoints2);
  scene.add(new THREE.Line(arcGeom2, lineMaterial));

  // --- BASKET / HOOP ---
  const backboard = new THREE.Mesh(
    new THREE.BoxGeometry(1.8, 1.05, 0.05),
    new THREE.MeshStandardMaterial({ color: 0xffffff })
  );
  backboard.position.set(0, 3, -6.9);
  backboard.castShadow = true;
  scene.add(backboard);

  const rim = new THREE.Mesh(
    new THREE.TorusGeometry(0.45, 0.03, 16, 100),
    new THREE.MeshStandardMaterial({ color: 0xff4500 })
  );
  rim.rotation.x = Math.PI/2;
  rim.position.set(0, 2.9, -6.45);
  rim.castShadow = true;
  scene.add(rim);




  // Handle window resize
  window.addEventListener('resize', onWindowResize);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
</script>
</body>
</html>


    
  
    
      
     
    


